# words-path-finder
Личный челлендж - написать одну и ту же программу на разных языках программирования.
Цель - сравнить процесс разработки на разных языках, научиться новому, расширить кругозор и немного развлечься.

### Постановка задачи
Программа представляет собой webapi server, который для двух переданных слов ищет возможный путь между ними.

Путь между словами состоит из промежуточных слов, где последующее отличается от предыдущего на одну букву. Например:
- муха
- мура
- мара
- пара
- парк
- паёк
- саёк
- саек
- стек
- стен
- стон
- слон

Методы API:

GET /api/wordsPath?from=word1&to=word2

Выдаёт найденный путь в формате
```
{
    "length": number,
    "steps": [
        string,
        string,
        ...
    ]
}
```

Если не указано хотя бы одно из слов или слова разной длины, выдаёт 400 BadRequest.

Если путь между словами не найден, выдаёт 404 NotFound.
### Дополнительные требования
Словари слов нужной длины должны получаться веб-запросом из папки https://github.com/plaptov/words-path-finder/tree/main/dict

Файлы слов сформированы из словаря Зализняка, взятого с http://speakrus.ru/dict2/index.htm (для задачи несущественно, можно хоть сгенерировать).

Поиск пути предлагается делать по алгоритму A* (A-star).

Граф слов для поиска должен кэшироваться в памяти (фромирование графа самая затратная часть).

Найденные пути сохраняются в БД (PostgreSQL) в таблицу
``` SQL
CREATE TABLE public."WordsPaths" (
	"From" text NOT NULL,
	"To" text NOT NULL,
	"Steps" text[] NULL,
	CONSTRAINT "PK_WordsPaths" PRIMARY KEY ("From", "To")
);
```
Сначала путь ищется в БД, а при отсутствии по графу.

Если язык поддерживает и синхронный, и асинхронный варианты, все IO-операции должны быть асинхронными.

Таким образом, хочется проверить такие возможности языка и экосистемы:
1. Удобство создания WebApi (одна из типовых задач на текущий день);
2. Асинхронные операции (это в тренде и полезно для утилизации ЦПУ, но может быть с хитростями);
3. Конкурентный доступ при многопоточности (насколько легко в целом, готовые решения);
4. Вызовы стороннего WebApi (интегрируемся со сторонней системой - тоже частая задача)
5. Работа с БД (нужно почти везде, плюс stateful всегда сложнее stateless)
6. Удобство написания алгоритмов (программист я или джейсоноукладыватель, в конце концов?)

### Допущения
Допускается хардкод строки соединения, меньшее дробление по проектам/папкам ввиду мелкого объёма задачи. Но по возможности надо придерживаться best practices.

### Формат
Каждое решение сохраняется в отдельную папку изолированно от остальных.

Если есть несколько вариантов на одном языке с разными фреймворками, они хранятся также отдельно, без общего кода.

В корне каждого решения хранится readme, где описаны субъективные результаты.

Описывается не только процесс разработки, но и установка компонентов, удобство инструментария и прочее.

Возможно, потом будет какая-то сводная таблица по всем решениям.

### Среда и инструментарий
Для единообразия по умолчанию всё делается в Ubuntu 22.10 и VSCode.

Если для языка нужны специфичные условия, это обязательно фиксируется в readme.
